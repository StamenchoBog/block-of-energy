##############################################################################################
#  Copyright Accenture. All Rights Reserved.
#
#  SPDX-License-Identifier: Apache-2.0
##############################################################################################

apiVersion: batch/v1
kind: Job
metadata:
  name: installchaincode-{{ $.Values.peer.name }}-{{ $.Values.chaincode.name }}-{{ $.Values.chaincode.version }}
  namespace: {{ $.Values.metadata.namespace }}
  labels:
    app: installchaincode-{{ $.Values.peer.name }}-{{ $.Values.chaincode.name }}-{{ $.Values.chaincode.version }}
    app.kubernetes.io/name: installchaincode-{{ $.Values.chaincode.name }}{{ $.Values.chaincode.version }}
    helm.sh/chart: {{ .Chart.Name }}-{{ .Chart.Version | replace "+" "_" }}
    app.kubernetes.io/managed-by: {{ .Release.Service }}
    app.kubernetes.io/instance: {{ .Release.Name }}
    {{- include "labels.custom" . | nindent 2 }}
spec:
  backoffLimit: 6
  template:
    metadata:
      labels:
        app: installchaincode-{{ $.Values.peer.name }}-{{ $.Values.chaincode.name }}-{{ $.Values.chaincode.version }}
        app.kubernetes.io/name: installchaincode-{{ $.Values.chaincode.name }}{{ $.Values.chaincode.version }}
        helm.sh/chart: {{ .Chart.Name }}-{{ .Chart.Version | replace "+" "_" }}
        app.kubernetes.io/managed-by: {{ .Release.Service }}
        app.kubernetes.io/instance: {{ .Release.Name }}
    spec:
      restartPolicy: OnFailure
      serviceAccountName: {{ $.Values.vault.serviceaccountname }}
      {{- if .Values.vault.imagesecretname }}
      imagePullSecrets:
        - name: {{ $.Values.vault.imagesecretname }}
      {{- end }}
      volumes:
      {{ if .Values.vault.tls  }}
        - name: vaultca
          secret:
            secretName: {{ $.Values.vault.tls }}
            items:
              - key: ca.crt.pem
                path: ca-certificates.crt
      {{ end  }}
        - name: certificates
          emptyDir:
            medium: Memory
        - name: admin-msp-secrets
          secret:
            secretName: {{ $.Values.secrets.adminMSPSecretName }}
            items:
              - key: admincerts
                path: admincerts
              - key: cacerts
                path: cacerts
              - key: keystore
                path: keystore
              - key: signcerts
                path: signcerts
              - key: tlscacerts
                path: tlscacerts
        - name: orderer-tls-secrets
          secret:
            secretName: {{ $.Values.secrets.ordererTLSSecretName }}
            items:
              - key: cacrt
                path: ca.crt
        - name: package-manager
          configMap:
            name: package-manager
        - name: docker-socket-volume
          hostPath:
            path: /run/containerd/containerd.sock
      initContainers:
        - name: certificates-init
          image: {{ $.Values.metadata.images.alpineutils }}
          imagePullPolicy: IfNotPresent
          env:
            - name: MOUNT_PATH
              value: /secret
            - name: NETWORK_VERSION
              value: "{{ $.Values.metadata.network.version }}"
            - name: VAULT_TYPE
              value: "{{ $.Values.vault.type }}"
          command: ["sh", "-c"]
          args:
            - |-
              #!/usr/bin/env sh

              OUTPUT_PATH="${MOUNT_PATH}/orderer/tls"
              mkdir -p ${OUTPUT_PATH}
              echo "${TLS_CA_CERT}" >> ${OUTPUT_PATH}/ca.crt

              # Copy TLS certificates from mounted K8s secrets
              echo "Getting Orderer TLS certificates from Kubernetes Secret"
              cat /msp-secrets/orderer-tls/ca.crt > ${OUTPUT_PATH}/ca.crt

              # Replace this with Kubernetes vault fetch
              ADMINCERT=$(echo ${VAULT_SECRET} | jq -r '.["admincerts"]')
              CACERTS=$(echo ${VAULT_SECRET} | jq -r '.["cacerts"]')
              KEYSTORE=$(echo ${VAULT_SECRET} | jq -r '.["keystore"]')
              SIGNCERTS=$(echo ${VAULT_SECRET} | jq -r '.["signcerts"]')
              TLSCACERTS=$(echo ${VAULT_SECRET} | jq -r '.["tlscacerts"]')

              echo "Getting MSP certificates from Kubernetes Secret"
              OUTPUT_PATH="${MOUNT_PATH}/admin/msp"
              mkdir -p ${OUTPUT_PATH}/admincerts
              mkdir -p ${OUTPUT_PATH}/cacerts
              mkdir -p ${OUTPUT_PATH}/keystore
              mkdir -p ${OUTPUT_PATH}/signcerts
              mkdir -p ${OUTPUT_PATH}/tlscacerts

              # Copy files from mounted Kubernetes secrets to target paths
              cat /msp-secrets/admin-msp/admincerts > ${OUTPUT_PATH}/admincerts/admin.crt
              cat /msp-secrets/admin-msp/cacerts > ${OUTPUT_PATH}/cacerts/ca.crt
              cat /msp-secrets/admin-msp/keystore > ${OUTPUT_PATH}/keystore/server.key
              cat /msp-secrets/admin-msp/signcerts > ${OUTPUT_PATH}/signcerts/server.crt
              cat /msp-secrets/admin-msp/tlscacerts > ${OUTPUT_PATH}/tlscacerts/tlsca.crt

              # Debug output
              echo "Certificate setup completed"
          volumeMounts:
        {{ if .Values.vault.tls  }}
            - name: vaultca
              mountPath: "/etc/ssl/certs/"
              readOnly: true
        {{ end }}
            - name: certificates
              mountPath: /secret
            - name: admin-msp-secrets
              mountPath: /msp-secrets/admin-msp
              readOnly: true
            - name: orderer-tls-secrets
              mountPath: /msp-secrets/orderer-tls
              readOnly: true
      containers:
        - name: installchaincode
          image: {{ $.Values.metadata.images.fabrictools }}
          imagePullPolicy: IfNotPresent
          stdin: true
          tty: true
          command: ["sh", "-c"]
          args:
            - |-
              #!/bin/bash
              set -ex

              # STEP 1: PACKAGE THE CHAINCODE ADDRESS REFERENCE
              # This creates a package that tells the peer how to find the chaincode service.
              mkdir -p /tmp/chaincode-pkg
              CHAINCODE_ADDRESS="{{ .Values.chaincode.name }}.{{ .Values.metadata.namespace }}:7052"
              cat << EOF > /tmp/chaincode-pkg/connection.json
              {
                "address": "${CHAINCODE_ADDRESS}",
                "dial_timeout": "10s",
                "tls_required": false
              }
              EOF
              tar -czf ${CHAINCODE_NAME}.tar.gz -C /tmp/chaincode-pkg .

              # STEP 2: INSTALL THE PACKAGE TO GET THE CHAINCODE_ID
              # The output of this command contains the package ID we need.
              peer lifecycle chaincode install ${CHAINCODE_NAME}.tar.gz

              PACKAGE_ID=$(peer lifecycle chaincode queryinstalled -O json | jq -r '.installed_chaincodes[0].package_id')
              if [ -z "$PACKAGE_ID" ]; then
                echo "Failed to get package ID. Exiting."
                exit 1
              fi
              echo "Got Chaincode Package ID: ${PACKAGE_ID}"

              # STEP 3: CREATE AND DEPLOY THE CHAINCODE SERVER
              # This script dynamically creates the Kubernetes manifests for your chaincode.
              cat << EOF > /tmp/chaincode-deployment.yaml
              apiVersion: apps/v1
              kind: Deployment
              metadata:
                name: ${CHAINCODE_NAME}-chaincode
                namespace: {{ .Values.metadata.namespace }}
                labels:
                  app: ${CHAINCODE_NAME}-chaincode
              spec:
                replicas: 1
                selector:
                  matchLabels:
                    app: ${CHAINCODE_NAME}-chaincode
                template:
                  metadata:
                    labels:
                      app: ${CHAINCODE_NAME}-chaincode
                  spec:
                    containers:
                      - name: chaincode
                        image: "{{ .Values.chaincode.image }}"
                        ports:
                          - containerPort: 9999
                        env:
                          - name: CHAINCODE_ID
                            value: "${PACKAGE_ID}"
                          - name: CHAINCODE_SERVER_ADDRESS
                            value: "0.0.0.0:9999"
              ---
              apiVersion: v1
              kind: Service
              metadata:
                name: ${CHAINCODE_NAME}
                namespace: {{ .Values.metadata.namespace }}
              spec:
                ports:
                  - name: grpc
                    port: 7052
                    targetPort: 9999
                selector:
                  app: ${CHAINCODE_NAME}-chaincode
              EOF

              # Use kubectl from within the pod to deploy the chaincode server
              kubectl apply -f /tmp/chaincode-deployment.yaml

              echo "Chaincode server deployed. PoC is complete!"
          env:
            - name: CORE_VM_ENDPOINT
              value: unix:///host/run/containerd/containerd.sock
            - name: PEER_NAME
              value: {{ $.Values.peer.name }}
            - name: PEER0_ADDRESS
              value: peer0.{{ $.Values.metadata.namespace }}:7051
            - name: PEER_ADDRESS
              value: {{ $.Values.peer.address }}
            - name: FABRIC_LOGGING_SPEC
              value: {{ $.Values.peer.loglevel }}
            - name: CORE_PEER_ID
              value: {{ $.Values.peer.name }}.{{ $.Values.metadata.namespace }}
            - name: CORE_PEER_ADDRESS
              value: {{ $.Values.peer.address }}
            - name: CORE_PEER_LOCALMSPID
              value: {{ $.Values.peer.localmspid }}
            - name: CORE_PEER_TLS_ENABLED
              value: "{{ $.Values.peer.tlsstatus }}"
            - name: CORE_PEER_TLS_ROOTCERT_FILE
              value: /opt/gopath/src/github.com/hyperledger/fabric/crypto/admin/msp/tlscacerts/tlsca.crt
            - name: ORDERER_CA
              value: /opt/gopath/src/github.com/hyperledger/fabric/crypto/orderer/tls/ca.crt
            - name: ORDERER_URL
              value: {{ $.Values.orderer.address }}
            - name: CORE_PEER_MSPCONFIGPATH
              value: /opt/gopath/src/github.com/hyperledger/fabric/crypto/admin/msp
            - name: CHAINCODE_NAME
              value: "{{ $.Values.chaincode.name }}"
            - name: CHAINCODE_MAINDIR
              value: "{{ $.Values.chaincode.maindirectory }}"
            - name: CHAINCODE_VERSION
              value: "{{ $.Values.chaincode.version }}"
            - name: CORE_CHAINCODE_BUILDER
              value: "{{ $.Values.chaincode.builder }}"
            - name: NETWORK_VERSION
              value: "{{ $.Values.metadata.network.version }}"
            - name: CC_RUNTIME_LANGUAGE
              value: "{{ $.Values.chaincode.lang }}"
          volumeMounts:
            - name: certificates
              mountPath: /opt/gopath/src/github.com/hyperledger/fabric/crypto
            - name: package-manager
              mountPath: /scripts/package-manager.sh
              subPath: package-manager.sh
            - name: docker-socket-volume
              mountPath: /host/run/containerd/containerd.sock
